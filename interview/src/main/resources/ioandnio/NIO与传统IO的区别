1、NIO 与传统 I/O 的区别？
传统IO就是一对一服务，NIO就是一对多服务。具体可以看https://blog.csdn.net/zhouhl_cn/article/details/6568119
人家讲的挺好的。IO的源码总结https://blog.csdn.net/panweiwei1994/article/details/78046000。

IO是为了解决IO（输入Input，输出OutPut）的问题。
从数据传输方式或者说是运输方式角度看，可以将IO分为字节流和字符流。
根据图片<<IO字节流和字符流划分.webp>>也可以看出，其实IO就是输入和输出，再分细一点就是字节流输入，字节流输出，字符流输入，字符流输出。
下面是具体的方法介绍。
InputStream 类

方法	方法介绍
public abstract int read()	读取数据
public int read(byte b[])	将读取到的数据放在 byte 数组中，该方法实际上是根据下面的方法实现的，off 为 0，len 为数组的长度
public int read(byte b[], int off, int len)	从第 off 位置读取 len 长度字节的数据放到 byte 数组中，流是以 -1 来判断是否读取结束的（注意这里读取的虽然是一个字节，但是返回的却是 int 类型 4 个字节，这里当然是有原因，这里就不再细说了，推荐这篇文章，链接）
public long skip(long n)	跳过指定个数的字节不读取，想想看电影跳过片头片尾
public int available()	返回可读的字节数量
public void close()	读取完，关闭流，释放资源
public synchronized void mark(int readlimit)	标记读取位置，下次还可以从这里开始读取，使用前要看当前流是否支持，可以使用 markSupport() 方法判断
public synchronized void reset()	重置读取位置为上次 mark 标记的位置
public boolean markSupported()	判断当前流是否支持标记流，和上面两个方法配套使用
OutputStream 类

方法	方法介绍
public abstract void write(int b)	写入一个字节，可以看到这里的参数是一个 int 类型，对应上面的读方法，int 类型的 32 位，只有低 8 位才写入，高 24 位将舍弃。
public void write(byte b[])	将数组中的所有字节写入，和上面对应的 read() 方法类似，实际调用的也是下面的方法。
public void write(byte b[], int off, int len)	将 byte 数组从 off 位置开始，len 长度的字节写入
public void flush()	强制刷新，将缓冲中的数据写入
public void close()	关闭输出流，流被关闭后就不能再输出数据了
再来看 Reader 和 Writer 类中的方法，你会发现和上面两个抽象基类中的方法很像。

Reader 类

方法	方法介绍
public int read(java.nio.CharBuffer target)	读取字节到字符缓存中
public int read()	读取单个字符
public int read(char cbuf[])	读取字符到指定的 char 数组中
abstract public int read(char cbuf[], int off, int len)	从 off 位置读取 len 长度的字符到 char 数组中
public long skip(long n)	跳过指定长度的字符数量
public boolean ready()	和上面的 available() 方法类似
public boolean markSupported()	判断当前流是否支持标记流
public void mark(int readAheadLimit)	标记读取位置，下次还可以从这里开始读取，使用前要看当前流是否支持，可以使用 markSupport() 方法判断
public void reset()	重置读取位置为上次 mark 标记的位置
abstract public void close()	关闭流释放相关资源
Writer 类

方法	方法介绍
public void write(int c)	写入一个字符
public void write(char cbuf[])	写入一个字符数组
abstract public void write(char cbuf[], int off, int len)	从字符数组的 off 位置写入 len 数量的字符
public void write(String str)	写入一个字符串
public void write(String str, int off, int len)	从字符串的 off 位置写入 len 数量的字符
public Writer append(CharSequence csq)	追加吸入一个字符序列
public Writer append(CharSequence csq, int start, int end)	追加写入一个字符序列的一部分，从 start 位置开始，end 位置结束
public Writer append(char c)	追加写入一个 16 位的字符
abstract public void flush()	强制刷新，将缓冲中的数据写入
abstract public void close()	关闭输出流，流被关闭后就不能再输出数据了

代码
1.读取控制台中的输入.详细请见IOTtest1
2.二进制文件的写入和读取.详细请见IOTest2
3.文本文件的写入和读取.详细请见IOTest3
write() 方法和 append() 方法并不是像方法名那样，一个是覆盖内容，一个是追加内容，append() 内部也是 write() 方法实现的，
也非说区别，也就是 append() 方法可以直接写 null，而 write() 方法需要把 null 当成一个字符串写入，所以两者并无本质的区别。

