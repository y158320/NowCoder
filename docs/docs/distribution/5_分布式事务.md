# 分布式事务

分布式事务指事务的操作位于**不同的节点**上，需要保证事务的 ACID 特性。

## 2PC

两阶段提交（Two-phase Commit，2PC）是基于分布式架构下的所有节点在进行事务提交时保持一致性而设计的一种算法。

在分布式系统中，每个节点虽然可以知晓自己的操作成功或者失败，却无法知道其他节点的操作成功或失败。

当一个节点跨域多个节点时，为了保证事务的 ACID 特性，需要引入一个**协调者（Coordinator）**来统一掌握所有节点（参与者）的操作结果并最终指示这些节点是否要把操作结果真正提交。

### 思路

参与者将操作成败通知协调者，再由协调者根据所有参与者反馈情况决定各参与者是否提交操作还是终止操作。

### 2 个阶段

**阶段1：请求阶段（commit-request phase）/ 表决阶段（voting phase）**

- 协调者节点向所有参与者节点询问是否可以执行提交操作，并开始等待各参与者节点的响应。

- 参与者节点执行询问发起为止的所有事务操作
- 各参与者节点响应协调者发起的询问



<div align="center"> <img src="https://gitee.com/duhouan/ImagePro/raw/master/java-notes/systemDesign/04f41228-375d-4b7d-bfef-738c5a7c8f07.jpg"/> </div><br>

**阶段2：提交阶段（commit phase）**

如果事务在每个参与者上都执行成功，事务协调者发送通知让参与者提交事务；否则，协调者发送通知让参与者回滚事务。

需要注意的是，在准备阶段，参与者执行了事务，但是还未提交。只有在提交阶段接收到协调者发来的通知后，才进行提交或者回滚。

<div align="center"> <img src="https://gitee.com/duhouan/ImagePro/raw/master/java-notes/systemDesign/2991c772-fb1c-4051-a9c7-932b68e76bd7.jpg"/> </div><br>

### 存在的问题

- 同步阻塞

  所有事务参与者在等待其它参与者响应的时候都处于同步阻塞状态，无法进行其它操作。

- 单点问题

协调者在 2PC 中起到非常大的作用，发生故障将会造成很大影响。特别是在阶段二发生故障，所有参与者会一直等待，无法完成其它操作。

- 数据不一致

  在阶段二，如果协调者只发送了部分 Commit 消息，此时网络发生异常，那么只有部分参与者接收到 Commit 消息，也就是说只有部分参与者提交了事务，使得系统数据不一致。

- 太过保守

  任意一个节点失败就会导致整个事务失败，没有完善的容错机制。

## TCC

TCC 即补偿事务，其实就是采用的**补偿机制**，其核心思想是：针对每个操作，都要注册一个与其对应的确认和补偿（撤销）操作。它分为三个阶段：

- Try 阶段主要是对业务系统做检测及资源预留；
- Confirm 阶段主要是对业务系统做确认提交，Try阶段执行成功并开始执行 Confirm阶段时，默认 Confirm阶段是不会出错的。即：只要Try成功，Confirm一定成功；
- Cancel 阶段主要是在业务执行错误，需要回滚的状态下执行的业务取消，预留资源释放。

举个例子，假入 Bob 要向 Smith 转账，思路大概是：
我们有一个本地方法，里面依次调用

1. 首先在 Try 阶段，要先调用远程接口把 Smith 和 Bob 的钱给冻结起来。
2. 在 Confirm 阶段，执行远程调用的转账的操作，转账成功进行解冻。
3. 如果第2步执行成功，那么转账成功，如果第二步执行失败，则调用远程冻结接口对应的解冻方法 (Cancel)。

### 优点

跟 2PC 比起来，实现以及流程相对简单了一些，但数据的一致性比 2PC 也要差一些

### 缺点

缺点还是比较明显的，在2,3步中都有可能失败。TCC 属于应用层的一种补偿方式，所以需要程序员在实现的时候多写很多补偿的代码，在一些场景中，一些业务流程可能用 TCC 不太好定义及处理。



## 本地消息表

此方案的核心是将需要分布式处理的任务通过消息日志的方式来异步执行。消息日志可以存储到本地文本、数据库或消息队列，再通过业务规则自动或人工发起重试。人工重试更多的是应用于支付场景，通过对账系统对事后问题的处理。

本地消息表与业务数据表处于同一个数据库中，这样就能利用本地事务来保证在对这两个表的操作满足事务特性，并且使用了消息队列来保证最终一致性。

1. 在分布式事务操作的一方完成写业务数据的操作之后向本地消息表发送一个消息，本地事务能保证这个消息一定会被写入本地消息表中。
2. 之后将本地消息表中的消息转发到 Kafka 等消息队列中，如果转发成功则将消息从本地消息表中删除，否则继续重新转发。
3. 在分布式事务操作的另一方从消息队列中读取一个消息，并执行消息中的操作。
4. 如果是业务上面的失败，可以给生产方发送一个业务补偿消息，通知生产方进行回滚等操作。

<div align="center"> <img src="https://gitee.com/duhouan/ImagePro/raw/master/java-notes/systemDesign/e3bf5de4-ab1e-4a9b-896d-4b0ad7e9220a.jpg" width="550"/> </div>

这种方案遵循 BASE 理论，采用的是最终一致性，笔者认为是这几种方案里面比较适合实际业务场景的，即不会出现像 2PC 那样复杂的实现(当调用链很长的时候，2PC的可用性是非常低的)，也不会像TCC那样可能出现确认或者回滚不了的情况。

### 优点

 一种非常经典的实现，避免了分布式事务，实现了最终一致性。在 .NET中 有现成的解决方案。

### 缺点

消息表会耦合到业务系统中，如果没有封装好的解决方案，会有很多杂活需要处理。



## MQ 事务消息

有一些第三方的MQ是支持事务消息的，比如RocketMQ，他们支持事务消息的方式也是类似于采用的二阶段提交，但是市面上一些主流的MQ都是不支持事务消息的，比如 RabbitMQ 和 Kafka 都不支持。

以阿里的 RocketMQ 中间件为例，其思路大致为：

第一阶段Prepared消息，会拿到消息的地址。
第二阶段执行本地事务。

第三阶段通过第一阶段拿到的地址去访问消息，消息接受者就能使用这个消息。

<div align="center">
    <img src="https://gitee.com/IvanLu1024/picts/raw/master/blog/distributed/rocketMq.jpeg"/>
</div>

也就是说在业务方法内要想消息队列提交两次请求，一次发送消息和一次确认消息。如果确认消息发送失败了RocketMQ会定期扫描消息集群中的事务消息，这时候发现了Prepared消息，它会向消息发送者确认，所以生产方需要实现一个check接口，RocketMQ会根据发送端设置的策略来决定是回滚还是继续发送确认消息。这样就**保证了消息发送与本地事务同时成功或同时失败**。

<div align="center">
    <img src="https://gitee.com/IvanLu1024/picts/raw/master/blog/distributed/rockteMq01.jpeg"/>
</div>
### 优点

实现了最终一致性，不需要依赖本地数据库事务。

### 缺点

实现难度大，主流 MQ 不支持，RocketMQ 事务消息部分代码也未开源。